# Лабораторна робота 3 : Інкапсуляція. Знайомство з мовою моделювання UML

## Завдання 1. Класи TimeSpan та BankAccount

Скопіюйте класи `TimeSpan` та `BankAccount` з попередньої лабораторної роботи та додайте модифікатору доступу до полів та методів (вам треба поміркувати та визначити, які модифікатори додавати до певних полів та методів).

У якості результату данного завдання в директорії з вихідним кодом повинні міститися файли `TimeSpan.java` та `BankAccount.java` з доданими модифікаторами.

## Завдання 2. Моделювання класів за допомогою діаграми класів UML

Використовуючи додаток StarUML, змоделюйте класи `TimeSpan` та `BankAccount` з попереднього завдання (із вже доданими модифікаторами).

У якості результату данного завдання, ви повинні додати файл StarUML з розширенням `mdj` до корню вашого репозиторію.

Завантажити StarUML - [посилання](https://staruml.io)

## Завдання 3. Матеріал з інкапсуляції

Для виконання завдання:

- уважно перечитайте матеріал, який викладений нижче;
- виконайте дії, які вказані в матеріалі;
- дайте відповідь на запитання, які поставлені в матеріалі.

У якості результату даної роботи ви повинні:

- створити нові класи у відповідних файлах та написати код в методі `main()`;
- дати розгортнуту відповідь на запитання у вигляді файлу у форматі Markdown. Файл повинен називатись answer.md та міститися у корні вашого репозиторію.

Синтаксис файлів у форматі Markdown - [посилання](https://www.markdownguide.org/cheat-sheet/)

----

Об'єктно-орієнтовані мови програмування, такі як Java, містять функції, які підтримують парадигму об'єктно-орієнтованого програмування. Ці функції включають абстракцію даних, інкапсуляцію, приховування інформації, поліморфізм і успадкування.

Інкапсуляція має на меті групування як даних, так і методів (поведінки) в єдину сутність під назвою клас, яку можна легко включити в різні програми. Клас, визначений у програмі Java, використовується для оголошення об'єктів цього класу. Використовуючи функцію інкапсуляції, програміст може обмежити доступ до компонентів класу, що є ключовою перевагою інкапсуляції в Java. Java класифікує члени класу (поля класу та методи) в одну з трьох категорій за допомогою специфікаторів доступу, які також є зарезервованими словами: `private`, `public` та `protected`. Специфікатори доступу  визначають видимість або доступність членів класу, як зазначено нижче:

- `private` - член класу доступний лише методам даного класу;
- `public` - член класу доступний для методів в даному класу та за межами даного класу (фактично, всюди в програмі);
- `protected` - член класу доступний для методів даного класу, для методів підкласів, а також для методів класів, які знаходиться в тому самому пакеті;
- без модифікатора (такий доступ називається *default* чи *package-private*) - член класу доступний для методів класів, які знаходяться в тому самому пакеті.

![таблиця з модифікаторами доступу](https://ucarecdn.com/0c1aee24-39dd-48c7-ab72-cd7e9872db99/)

У Java специфікатор доступу може вказуватися для поля класу та для методу перед типом даних. Будьте обережні! Коли модифікатор не вказаний, специфікатор доступу за замовчуванням є відкритим, що означає, що методи в будь-якому класі в тому самому пакеті, або той, який імпортує цей пакет, зможуть використовувати, отримати доступ або змінити цих учасників.

Розглянемо даний клас

```java
public class Time {
    private int hour;
    private int minute;
    private int second;

    public Time() { 
        /* constructor implementation */ 
    }

    public void setTime(int newHour, int newMinute, int newSecond) {
        /* mutator implementation */ 
    }

    public int[] getTime() { 
        /* accessor implementation */ 
    }

    public void incrementTime() { 
        /* mutator implementation */ 
    }
}
```

В прикладі вище, поля класу hour, minute та second, а також методи-члени `setTime()`, `getTime()` і `incrementTime()` об'єднані в
єдиний автономний клас під назвою `Time`. Це демонструє функцію інкапсуляції Java. Коли всі дані оголошено як `private`, вони доступні лише в методах даного класу. Цей обмежений доступ проілюстровано нижче.

![ілюстрація принципу інкапсуляції](http://cisserv1.towson.edu/~cssecinj/wp-content/uploads//encapsulation.JPG)

Такий обмежений доступ вимагає від програмістів написання спеціалізованих методів доступу, таких як `getTime()` для отримання значень приватних полів, і спеціалізованих методів-мутаторів, таких як `setTime()` і `incrementTime()` для виконання операцій над ними. Це дозволяє програмістам перевіряти зміни в полях класу перед тим, як встановити ці значення. У цьому прикладі метод `setTime()` повинен мати код для перевірки дійсних значень для часу (година знаходиться в діапазоні від `0` до `23`, а хвилина і секунда в діапазоні від `0` до `59`).

Інкапсуляція приховує приватні члени класу, а також деталі реалізації,але це не означає, що клас становиться повністю ізольованим. Для роботи програми, багато об'єктів повинні обмінюватися інформацією з іншими об'єктами. Однак, захист приватних даних за допомогою методів-акцесорів та методів-мутаторів дозволяє бути впевненим, що вплив інших об'єктів буде здійснюватися тільки певним відомим чином. Обмін даними повинен бути мінімізований, тому клас повинен представляти як можна менший інтерфейс (сукупність публічних методів). Інші методи повинні бути приватними, щоб вони не були доступні ззовні класу.

Використання інкапсуляції належним чином та забезпечення контрольованого публічного інтерфейсу схоже на ресторан швидкого харчування, в якому клієнтам доступні тільки вікна для автомобілів.Клієнт може прочитати меню, розміщувати замовлення з меню, платити за замовлення та забрати виконане замовлення. Покупець не знає точно, що відбувається всередині ресторану; він знає лише, що замовлення та оплата за це призводить до того, що їжа з’являється у вікні видачі замовлення. Замовник може кожен день повертатися в той самий ресторан швидкого харчування і так само взаємодіяти з рестораном. Якщо ресторан наймає консультанта, щоб скоротити витрати та змінити спосіб виконання замовлень, замовник не знає про зміни, і насправді йому не потрібно
знати про це. Поки замовник взаємодіє з рестораном однаково, і їжа на смак щоразу так само хороша, клієнту нецікаво знати про внутрішні операції ресторану.

Належне використання інкапсуляції в Java підвищує безпеку програми з кількох причин:

1. Початкове значення всіх членів даних контролюється програмістом, що пише код для класу;
2. Доступ до даних об'єкта контролюється програмістом, що пишу код для класу, що призводить до меншої кількості людських помилок, спричинених неправильним використанням класу. Інкапсульовані об'єкти, які оголошують дані як `private` або `protected`, виступають як чорний ящик, захищаючи дані об'єкта та дозволяють доступ до даних лише викликаючи методи класу, які контролюють, як можна отримати доступ та змінювати дані. Дані захищені, оскільки вони можуть бути доступні лише у безпечний спосіб, так само, як захищений банківський рахунок, оскільки до нього можна отримати доступ лише безпечно.
3. Інкапсульовані об'єкти забезпечують повну функціональність; однак зовнішній код, який використовує дані об'єкти, не знає деталей реалізації, і не може покладатися на ту чи іншу реалізацію функціоналу об'єкту. Це означає, що реалізація може бути вдосконалена або оновлена ​​в майбутньому, не впливаючи на процес роботи з об'єктами зі сторони зовнішнього коду.
4. Якщо клас ізолюється від впливу інших класів програми за допомогою інкапсуляції, тоді легше простежити помилку до класу, який спричинив її та обмежити пошкодження, спричинені несправністю.

Якщо програміст не використовує інкапсуляцію належним чином, існування функції інкапсуляції на Java не забезпечує підвищену безпеку. Насправді, використовуючи інкапсуляція неправильно може значно підвищити небезпечність додатку. Порушення інкапсуляції збільшують небезпечність у додатку прямо пропорційно тому, скільки функціональної логіки містить клас. Якщо клас зберігає один простий елемент даних, наприклад, `char`, значення якого може бути будь-який коректний символ, то порушення інкапсуляції, ймовірно, не є великою проблемою. По мірі ускладнення даних, порушення інкапсуляції створюють все більше і більше небезпеки, оскільки спеціальні властивості даних (наприклад, обмеження години до значень між `0` і `23`, включно), має все більше шансів на порушення.

Оскільки правила належної інкапсуляції порушуються, всі клієнти класу стають відповідальними за все більшу кількість коду, який коректно отримує доступ та використовує дані об'єкту. Оскільки клас вдосконалюється та оновлюється з часом, неможливо виправити всі використання класу, особливо якщо зовнішні користувачі класу не контролюються програмістом. Врешті-решт, клас повністю втрачає цілісність і стає вразливим для безпеки додатку.

Розглянемо наступний код

```java
public class RiskyTime {
    int hour;
    int minute;
    int second;
    void setTime(int newHour, int newMinute, int newSecond)
        { /* mutator implementation */ }
    int[] getTime()
        { /* accessor implementation */ }
    void incrementTime()
        { /* mutator implementation */ }
};
```

Клас `RiskyTime` не має скромності; без явного оголошення того, що його дані повинні бути приватними, вони публічно "висять" на виду у всьому додатку. Причина того, що це є недоліком така ж, як і у звичайної людини. Коли у людини щось виставлено на показ, воно може отримати сонячні опіки у неправильних місцях. Коли дані виставлені на показ, інші компоненти мають повний доступ до цих даних, що може причинити шкоду. Оскільки клас `RiskyTime` дозволяє всім методам у всьому додатку прямий доступ до членів класу, зовнішній метод може виставити значення годин, хвилин та секунд таким чином, що час будет некоректним, наприклад, `36:99:-33`. Клієнти, які використовують клас, не можуть розраховувати на те, що час буде коректним. Якщо клієнт все-таки використовує клас, і не перевіряє, щоб бути впевненим, що дані об'єкта дійсні кожного разу, коли він використовується, недійсні значення можуть спричинити дивні, і навіть небезпечні речі під час виконання додатку.

**Як використовувати інкапсуляцію належним чином?**

1. Обмежте доступ: оголосіть всі поля класу як приватні. Крім того, оголосіть всі методи, які не потрібно викликати зовнішнім компонентам додатку, приватними. Створіть публічні методи, щоб забезпечити контрольований інтерфейс між даними об'єкта та всіма зовнішніми компонентами додатку;
2. Знайте межі: ознайомтеся з діапазоном дійсних значень для кожного елемента даних, що зберігається в класі;
3. Ініціалізуйте дані: Встановіть усі елементи даних на дійсні початкові значення для порожнього або неіснуючого об'єкта за допомогою конструктора за замовчуванням;
4. Обирайте типи даних з розумом: наприклад, Java містить кілька типів даних для зберігання цілих значень. Обов'язково виберіть великі цілі типи, які можуть зберігати всі дійсні значення поля;
5. Перевіряйте вхідні значення: Перевірте вхід на коректність, перш ніж змінити значення даних, що зберігаються в об'єкті;
6. Двічі перевірте всі операції, що виконуються в класу: переконайтеся, що будь-які операції, які змінюють дані, такі як збільшення часу, підтримують коректність усіх елементів даних.

**Завдання**. Даний наступний вихідний код

```java
// Файл Time.java
public class Time {
    final int MAX_HOURS = 23;
    final int MAX_MIN_SECS = 59;
    int hour;
    int minute;
    int second;

    void setTime(int newHour, int newMinute, int newSecond) {
        hour = newHour;
        minute = newMinute;
        second = newSecond;
    }

    int[] getTime() {
        return new int[]{hour, minute, second};
    }

    void incrementTime() {
        ++second;
    }
}

// Файл Time.java
public class Main {
    public static void main(String[] args) {
        int hr;
        int min;
        int sec;
        int[] temp;
        Time currTime = new Time();
        currTime.setTime(20, 15, 43);
        temp = currTime.getTime();
        hr = temp[0];
        min = temp[1];
        sec = temp[2];
        System.out.println(
                "Поточний встановлений час: "
                        + hr + ":" + min + ":" + sec
        );
        currTime.incrementTime();
        temp = currTime.getTime();
        hr = temp[0];
        min = temp[1];
        sec = temp[2];
        System.out.println(
                "Після інкременту часу, поточний час: "
                        + hr + ":" + min + ":" + sec
        );
    }
}
```

**Ход роботи**

1. Створіть файл з класом `Time.java` та додайте відповідний код до функції `main()`. Скомпілюйте та запустіть додаток.
2. Зверніть увагу на вихідні дані. Чи мають вони сенс? Чому так або чому ні?
3. Змініть виклик `currTime.setTime()` в функції `main()` на наступний, після чого скомпілюйте та запустіть додаток.

```java
currTime.setTime(-55, 99, 1025);
```

4. Зверніть увагу на нові вихідні дані. Чи мають вони сенс? Чому так або чому ні?

5. Додайте наступний код в кінець функції `main()`. Скомпілюйте та запустіть додаток.

```java
currTime.hour = 31;
currTime.minute = -10;
currTime.second = 450;
temp = currTime.getTime();
hr = temp[0];
min = temp[1];
sec = temp[2];
System.out.println(
        "After direct assignment, the current military time is:"
                + hr + ":" + min + ":" + sec
);
```

6. Зверніть увагу на останній рядок вихідних даних. Чи має він сенс? Чому так або чому ні?

7. Нам потрібно виправити проблему, що була викликана оголошенням полів класу `Time` як `public`. Змініть класс `Time`, оголосивши три поля приватними. Скомпілюйте та запустіть додаток. Що трапилось? Чому?

8. Видаліть код, який був доданий на 5 кроці. Скомпілюйте та запустіть додаток.

9. Виправте метод `setTime()`. Змініть його наступним чином. Скомпілюйте та запустіть додаток.

```java
void setTime(int newHour, int newMinute, int newSecond) {
    if (newHour >= 0 && newHour <= MAX_HOURS) {
        hour = newHour;
    } else {
        System.out.println("Error: hour must be between 0 and 23 inclusive");
        hour = 0;
    }
    
    if (newMinute >= 0 && newMinute <= MAX_MIN_SECS) {
        minute = newMinute;
    } else {
        System.out.println("Error: minute must be between 0 and 59 inclusive");
        minute = 0;
    }
    
    if (newSecond >= 0 && newSecond <= MAX_MIN_SECS) {
        second = newSecond;
    } else {
        System.out.println("Error: second must be between 0 and 59 inclusive");
        second = 0;
    }
}
```

10. Чому нова версія методу `setTime()` є більш безпечною, ніж попередня версія?

11. Зверніть увагу на нові вихідні дані. Чи мають вони сенс? Чому так або чому ні?

12. Змініть виклик `currTime.setTime()` в `Main.java` на наступний. Скомпілюйте та запустіть додаток.

```java
currTime.setTime(23, 59, 59);
```

13. Зверніть увагу на нові вихідні дані. Чи мають вони сенс? Чому так або чому ні?

14. Додайте відповідний конструктор до класу `Time`. Скомпілюйте та запустіть додаток.

15. Які значення повинні бути використані для ініціалізації годин, хвилин та секунд у конструкторі?

16. Тепер треба виправити метод `incrementTime()`. Змініть цей метод наступним чином. Скомпілюйте та запустіть додаток.

```java
void incrementTime() {
    second = ++second % (MAX_MIN_SECS + 1);
    if (second == 0) {
        minute = ++minute % (MAX_MIN_SECS + 1);
    }
    if (minute == 0) {
        hour = ++hour % (MAX_HOURS + 1);
    }
}
```

17. Чому дана версія методу `incrementTime()` є більш безпечною ніж попередня версія методу?

18. Зверніть увагу на нові вихідні дані. Чи мають вони сенс? Чому так або чому ні?

19. Додайте наступний код у функцію `main()` перед викликом `currTime.setTime()`. Скомпілюйте та запустіть додаток.

```java
temp = currTime.getTime();
hr = temp[0];
min = temp[1];
sec = temp[2];
System.out.println(
        "The initial military time is set to: "
                + hr + ":" + min + ":" + sec
);
```

20. Зверніть увагу на перший рядок вихідних даних. Чи мають він сенс? Чому так або чому ні?

**Питання для дискусії**

1. Чому публічні поля класу є великою проблемою з точки зору безпеки?

2. Чи створюють методи-акцесори вразливості у класі? Чому так або чому ні?

3. Чому важливо для програміста знати діапазон коректних значень для кожного поля класу?

4. Чи прийнятно опускати конструктори за замовчуванням у класі? Чому так або чому ні?

5. Чому потрібно дуже ретельно обирати типи даних для полів класу?

6. Чому метод-мутатор повинен перевіряти вхідні дані перед тим, як змінювати атрибут об'єкту?

7. Чому важливо для програміста ретельно перевіряти будь-які операції, що змінюють значення атрибутів в об'єкті?
